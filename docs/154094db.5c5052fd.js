(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{163:function(e,t,n){"use strict";n.d(t,"a",(function(){return p})),n.d(t,"b",(function(){return m}));var a=n(0),r=n.n(a);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=r.a.createContext({}),b=function(e){var t=r.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=b(e.components);return r.a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},u=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,i=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),p=b(n),u=a,m=p["".concat(i,".").concat(u)]||p[u]||d[u]||o;return n?r.a.createElement(m,l(l({ref:t},c),{},{components:n})):r.a.createElement(m,l({ref:t},c))}));function m(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=u;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l.mdxType="string"==typeof e?e:a,i[1]=l;for(var c=2;c<o;c++)i[c]=n[c];return r.a.createElement.apply(null,i)}return r.a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},73:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return i})),n.d(t,"metadata",(function(){return l})),n.d(t,"rightToc",(function(){return s})),n.d(t,"default",(function(){return b}));var a=n(3),r=n(7),o=(n(0),n(163)),i={title:"Json Matchers",slug:"json-matchers.html",sidebar_label:"Json"},l={unversionedId:"assertions/json",id:"assertions/json",isDocsHomePage:!1,title:"Json Matchers",description:"Kotest provides powerful JSON assertions in the kotest-assertions-json module.",source:"@site/docs/assertions/json.md",slug:"/assertions/json-matchers.html",permalink:"/docs/assertions/json-matchers.html",editUrl:"https://github.com/kotest/kotest/blob/master/documentation/docs/assertions/json.md",version:"current",sidebar_label:"Json",sidebar:"assertions",previous:{title:"Core Matchers",permalink:"/docs/assertions/core-matchers.html"},next:{title:"Ktor Matchers",permalink:"/docs/assertions/ktor-matchers.html"}},s=[{value:"shouldEqualJson",id:"shouldequaljson",children:[{value:"compareJsonOptions",id:"comparejsonoptions",children:[]},{value:"shouldEqualSpecifiedJson",id:"shouldequalspecifiedjson",children:[]}]},{value:"shouldContainJsonKey",id:"shouldcontainjsonkey",children:[]},{value:"shouldContainJsonKeyValue",id:"shouldcontainjsonkeyvalue",children:[]},{value:"shouldMatchJsonResource",id:"shouldmatchjsonresource",children:[]}],c={rightToc:s};function b(e){var t=e.components,n=Object(r.a)(e,["components"]);return Object(o.b)("wrapper",Object(a.a)({},c,n,{components:t,mdxType:"MDXLayout"}),Object(o.b)("p",null,"Kotest provides powerful JSON assertions in the ",Object(o.b)("inlineCode",{parentName:"p"},"kotest-assertions-json")," module.\nThese allow flexible testing of json strings without the need to worry about formatting or ordering.\nThey provide precise error messages when comparing json so that the error can be easily found in a large json structure."),Object(o.b)("p",null,"This module is available for JVM and JS targets."),Object(o.b)("h2",{id:"shouldequaljson"},"shouldEqualJson"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"json.shouldEqualJson(other)")," asserts that the left-hand side represents the same\nJSON structure as the right-hand side."),Object(o.b)("p",null,"The matcher allows for different formatting, and for different order of keys."),Object(o.b)("p",null,"For example, the following two JSON strings would be considered equal:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{\n   "name": "sam",\n   "location": "chicago",\n   "age" : 41\n}\n')),Object(o.b)("p",null,"and"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-json"}),'{ "age" : 41, "name": "sam", "location": "chicago" }\n')),Object(o.b)("p",null,"The inverse of this matcher is ",Object(o.b)("inlineCode",{parentName:"p"},"shouldNotEqualJson")," which will error if two JSON strings\n",Object(o.b)("em",{parentName:"p"},"are")," considered equal."),Object(o.b)("h3",{id:"comparejsonoptions"},"compareJsonOptions"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},"shouldEqualJson")," supports an additional parameter of type ",Object(o.b)("inlineCode",{parentName:"p"},"CompareJsonOptions")," which supports the following flags to toggle behaviour of the JSON comparison:"),Object(o.b)("h4",{id:"usage"},"Usage:"),Object(o.b)("p",null,"Options can be specified inline, like:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-kotlin"}),"a.shouldEqualJson(b, compareJsonOptions { arrayOrder = ArrayOrder.Strict })\n")),Object(o.b)("p",null,"Another option is to define a compare function which suits your desires, like:"),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-kotlin"}),'val myOptions = compareJsonOptions {\n   typeCoercion = TypeCoercion.Enabled\n   arrayOrder = ArrayOrder.Lenient\n}\n\ninfix fun String.lenientShouldEqualJson(other: String) = this.shouldEqualJson(other, myOptions)\n\n"[1, 2]" lenientShouldEqualJson "[2, 1]" // This will pass\n')),Object(o.b)("h4",{id:"parameters"},"Parameters"),Object(o.b)("table",null,Object(o.b)("thead",{parentName:"table"},Object(o.b)("tr",{parentName:"thead"},Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Name"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Purpose"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Possible values"),Object(o.b)("th",Object(a.a)({parentName:"tr"},{align:null}),"Default value"))),Object(o.b)("tbody",{parentName:"table"},Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"PropertyOrder")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Determines if the order of properties in JSON objects are considered when comparing"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"PropertyOrder.Strict"),", ",Object(o.b)("inlineCode",{parentName:"td"},"PropertyOrder.Lenient")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"PropertyOrder.Lenient"),", i.e. order of properties ",Object(o.b)("em",{parentName:"td"},"DON'T")," matter")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"ArrayOrder")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Determines if the order of elements in JSON arrays are considered when comparing"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"ArrayOrder.Strict"),", ",Object(o.b)("inlineCode",{parentName:"td"},"ArrayOrder.Lenient")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"ArrayOrder.Strict"),", i.e. order of elements ",Object(o.b)("em",{parentName:"td"},"DO")," matter")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"FieldComparison")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Determines if comparison will fail if JSON objects ",Object(o.b)("inlineCode",{parentName:"td"},"actual")," contain extra properties, when compared to ",Object(o.b)("inlineCode",{parentName:"td"},"expected")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"FieldComparison.Strict"),", ",Object(o.b)("inlineCode",{parentName:"td"},"FieldComparison.Lenient")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"FieldComparison.Strict"),", i.e. extra properties will cause inequality")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"NumberFormat")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Determines if comparison of numbers are strict with regards to number format. For instance, if 100.0 and 100 are considered equal."),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"NumberFormat.Strict"),", ",Object(o.b)("inlineCode",{parentName:"td"},"NumberFormat.Lenient")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"NumberFormat.Lenient"),", i.e. number formats ",Object(o.b)("em",{parentName:"td"},"DON'T")," matter")),Object(o.b)("tr",{parentName:"tbody"},Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"TypeCoercion")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),"Determines if types will try to be coerced, for instance when a string contains a number or boolean value"),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"TypeCoercion.Enabled"),", ",Object(o.b)("inlineCode",{parentName:"td"},"TypeCoercion.Disabled")),Object(o.b)("td",Object(a.a)({parentName:"tr"},{align:null}),Object(o.b)("inlineCode",{parentName:"td"},"TypeCoercion.Disabled"),", i.e. types will ",Object(o.b)("em",{parentName:"td"},"NOT")," be coerced")))),Object(o.b)("p",null,"Targets: ",Object(o.b)("strong",{parentName:"p"},"JVM"),", ",Object(o.b)("strong",{parentName:"p"},"JS")),Object(o.b)("h3",{id:"shouldequalspecifiedjson"},"shouldEqualSpecifiedJson"),Object(o.b)("p",null,"Alias for ",Object(o.b)("inlineCode",{parentName:"p"},"shouldEqualJson"),", with default options except ",Object(o.b)("inlineCode",{parentName:"p"},"FieldComparison")," which is set to ",Object(o.b)("inlineCode",{parentName:"p"},"FieldComparison.Lenient")," instead."),Object(o.b)("pre",null,Object(o.b)("code",Object(a.a)({parentName:"pre"},{className:"language-kotlin"}),'val a = """ { "a": true, "date": "2019-11-03" } """\nval b = """ { "a": true } """\n\n// this would pass\na shouldEqualSpecifiedJson b\n\n// this would fail\na shouldEqualJson b\n')),Object(o.b)("p",null,"Targets: ",Object(o.b)("strong",{parentName:"p"},"JVM"),", ",Object(o.b)("strong",{parentName:"p"},"JS")),Object(o.b)("h2",{id:"shouldcontainjsonkey"},"shouldContainJsonKey"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},'json?.shouldContainJsonKey("$.json.path")')," asserts that a JSON string contains the given JSON path."),Object(o.b)("p",null,"The inverse of this matcher is ",Object(o.b)("inlineCode",{parentName:"p"},"shouldNotContainJsonKey")," which will error if a JSON string ",Object(o.b)("em",{parentName:"p"},"does")," contain the given JSON path."),Object(o.b)("p",null,"Targets: ",Object(o.b)("strong",{parentName:"p"},"JVM")),Object(o.b)("h2",{id:"shouldcontainjsonkeyvalue"},"shouldContainJsonKeyValue"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},'str?.shouldContainJsonKeyValue("$.json.path", value)')," asserts that a JSON string contains a JSON path with a specific ",Object(o.b)("inlineCode",{parentName:"p"},"value"),"."),Object(o.b)("p",null,"The inverse of this matcher is ",Object(o.b)("inlineCode",{parentName:"p"},"shouldNotContainJsonKeyValue")," which will error if a JSON string ",Object(o.b)("em",{parentName:"p"},"does")," contain the given value at the given JSON path."),Object(o.b)("p",null,"Targets: ",Object(o.b)("strong",{parentName:"p"},"JVM")),Object(o.b)("h2",{id:"shouldmatchjsonresource"},"shouldMatchJsonResource"),Object(o.b)("p",null,Object(o.b)("inlineCode",{parentName:"p"},'json?.shouldMatchJsonResource("/file.json")')," asserts that the JSON is equal to the existing test reosource ",Object(o.b)("inlineCode",{parentName:"p"},"/file.json"),", ignoring properties' order and formatting."),Object(o.b)("p",null,"Targets: ",Object(o.b)("strong",{parentName:"p"},"JVM")),Object(o.b)("div",{className:"admonition admonition-note alert alert--secondary"},Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-heading"}),Object(o.b)("h5",{parentName:"div"},Object(o.b)("span",Object(a.a)({parentName:"h5"},{className:"admonition-icon"}),Object(o.b)("svg",Object(a.a)({parentName:"span"},{xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"}),Object(o.b)("path",Object(a.a)({parentName:"svg"},{fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"})))),"note")),Object(o.b)("div",Object(a.a)({parentName:"div"},{className:"admonition-content"}),Object(o.b)("p",{parentName:"div"},"JSON matchers on the JVM are built using the Jackson library."))))}b.isMDXComponent=!0}}]);